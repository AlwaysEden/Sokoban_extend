        -:    0:Source:recv_msg.c
        -:    0:Graph:recv_msg.gcno
        -:    0:Data:recv_msg.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <unistd.h>
        -:    3:#include <fcntl.h>
        -:    4:#include <string.h>
        -:    5:
        -:    6:#define queue_size 20//본 프로그램에서 Queue size는 20으로 고정되어 있다.
        -:    7:
        -:    8:int event_arry[queue_size]; 
        -:    9:int rear = 1;
        -:   10:int front = 0; //rear와 front는 현재 이렇다는 상황 가정.
        -:   11:
        -:   12:
function recv_msg called 1 returned 100% blocks executed 82%
        1:   13:void recv_msg(void * arg)   // read thread main
        -:   14:{
        1:   15:        int sock = *((int*)arg);
        -:   16:       	char recv_cmd; //int->char로 변경. testing을 위해서 
        -:   17:
        -:   18:        //now enter new move
        -:   19:        while(1){
        1:   20:                if(read(sock, &recv_cmd, sizeof(recv_cmd)) == -1) //recv_byte()를 사용하는 곳이지만 read로 대체
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:   21:                        return (void)-1;
        -:   22:		//recv_cmd의 값은 서버에서 받기 때문에 값이 보장되어 있음.
        1:   23:        	fprintf(stderr, "From Server : %c\n", recv_cmd);
call    0 returned 1
        -:   24:
        -:   25:                //pthread_mutex_lock(&mutx);
        2:   26:                while((rear+1)%queue_size == front)
branch  0 taken 0
branch  1 taken 1 (fallthrough)
        -:   27:                        //pthread_cond_wait(&cond, &mutx);
    #####:   28:                rear = (rear + 1) % queue_size;
        1:   29:                event_arry[rear] = recv_cmd;
        -:   30:                //pthread_cond_signal(&cond);
        -:   31:                //pthread_mutex_unlock(&mutx);
        1:   32:		break; // 한번 돌고 break하는 이유는 다른 함수에 의해서 front가 조정되어야지 한번 더 도는게 의미가 있는데, 현 시점에서는 의미가 없기 때문이다.
        -:   33:        }
        1:   34:        return;
        -:   35:}
        -:   36:
function main called 1 returned 100% blocks executed 100%
        1:   37:int main(int argc, char *argv[]){
        -:   38:	char file[256];
        1:   39:	strcpy(file, argv[1]);
        1:   40:	int fd = open(file, O_RDONLY);
call    0 returned 1
        1:   41:	recv_msg((void*)&fd);	
call    0 returned 1
        -:   42:}
