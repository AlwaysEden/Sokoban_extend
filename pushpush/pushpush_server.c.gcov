        -:    0:Source:pushpush_server.c
        -:    0:Graph:pushpush_server.gcno
        -:    0:Data:pushpush_server.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <unistd.h>
        -:    4:#include <string.h>
        -:    5:#include <arpa/inet.h>
        -:    6:#include <sys/socket.h>
        -:    7:#include <sys/stat.h>
        -:    8:#include <netinet/in.h>
        -:    9:#include <pthread.h>
        -:   10:#include "../cJSON.h"
        -:   11:#include <signal.h>
        -:   12:
        -:   13:#define BUF_SIZE 256
        -:   14:#define MAX_USER 4
        -:   15:#define NAME_SIZE 16
        -:   16:#define PATH_LENGTH 256
        -:   17:
        -:   18:int usr_cnt = 0; //num of connected user
        -:   19:int game_start = 0;
        -:   20:int max_user;
        -:   21:char ** user_name;
        -:   22:int json_size;
        -:   23:char * json_serialize;
        -:   24:
        -:   25:int clnt_cnt = 0;
        -:   26:int clnt_socks[MAX_USER];
        -:   27:pthread_mutex_t mutx;
        -:   28:
        -:   29:int loadJson();
        -:   30:void disconnected(int sock);
        -:   31:int write_byte(int sock, void * buf, int size);
        -:   32:int read_byte(int sock, void * buf, int size);
        -:   33:void send_msg_all(void * event, int len);
        -:   34:void *handle_clnt(void * arg);
        -:   35:void error_handling(char * msg);
        -:   36:
        -:   37:
        -:   38://loadJson: read datas from json file
function loadJson called 1 returned 100% blocks executed 69%
        1:   39:int loadJson() 
        -:   40:{
        -:   41:	char filepath[PATH_LENGTH];
        1:   42:	fgets(filepath, PATH_LENGTH-1, stdin);
        1:   43:	filepath[strlen(filepath)-1]=0;
        1:   44:	FILE *file = fopen(filepath,"r");
        1:   45:	if(file == NULL)
branch  0 taken 0
branch  1 taken 1
        -:   46:	{
    #####:   47:		fprintf(stderr,"ERROR: open file");
    #####:   48:		return 1;
        -:   49:	}
        -:   50:	struct stat st;
        1:   51:	if(stat(filepath, &st) == -1)
branch  0 taken 0
branch  1 taken 1
        -:   52:	{
    #####:   53:  		fprintf(stderr,"ERROR: stat()\n");
    #####:   54:  		return 1;
        -:   55:	}
        1:   56:	int size = st.st_size;
        -:   57:
        1:   58:	char* jsonfile = (char*)malloc(size+1);
        1:   59:	if(jsonfile 	== NULL)
branch  0 taken 0
branch  1 taken 1
        -:   60:	{
    #####:   61:		fprintf(stderr,"ERROR: memory allocation\n");
    #####:   62:		return 1;
        -:   63:	}
        -:   64:
        1:   65:	int read_size = fread(jsonfile, 1, size, file);
        1:   66:	if(read_size != size)
branch  0 taken 0
branch  1 taken 1
        -:   67:	{
    #####:   68:		fprintf(stderr, "ERROR: read file\n");
    #####:   69:		return 1;
        -:   70:	}
        -:   71:
        1:   72:	fclose(file);
        1:   73:	jsonfile[size] = '\0';
        -:   74:	
        1:   75:	cJSON* root = cJSON_Parse(jsonfile);
        1:   76:	if (root == NULL) 
branch  0 taken 0
branch  1 taken 1
        -:   77:	{
    #####:   78:		printf("JSON 파싱 오류: %s\n", cJSON_GetErrorPtr());
    #####:   79:      	return 1;
        -:   80:	}
        -:   81:
        1:   82:	cJSON* num_user = cJSON_GetObjectItem(root, "max_user");
        1:   83:	max_user = num_user->valueint;
        1:   84:	user_name = (char**)malloc(sizeof(char*) * max_user);
        4:   85:	for(int i=0; i< max_user; i++)
branch  0 taken 1
branch  1 taken 1
        -:   86:	{
        1:   87:		user_name[i] = (char*)malloc(sizeof(char) * NAME_SIZE);
        1:   88:	}
        -:   89:
        1:   90:	json_serialize = cJSON_Print(root);
        1:   91:	json_size = strlen(json_serialize);
        -:   92:	
        1:   93:	free(root);
        1:   94:	free(jsonfile);
        1:   95:	return 0;
        1:   96:}
        -:   97:
        -:   98://disconnected: check if any user is disconnected, handel clnt_cnt
function disconnected called 1 returned 100% blocks executed 75%
        1:   99:void disconnected(int sock)
        -:  100:{
        1:  101:	fprintf(stderr,"This is disconntected\n");
        1:  102:	pthread_mutex_lock(&mutx);
        2:  103:	for (int i = 0; i < clnt_cnt; i++)   // remove disconnected client
branch  0 taken 1
branch  1 taken 0
        -:  104:	{
        1:  105:		if (sock == clnt_socks[i])
branch  0 taken 1
branch  1 taken 0
        -:  106:		{
        2:  107:			while (i < clnt_cnt-1)
branch  0 taken 0
branch  1 taken 1
        -:  108:			{
    #####:  109:				clnt_socks[i] = clnt_socks[i+1];
    #####:  110:				i++;
        -:  111:			}
        1:  112:			break;
        -:  113:		}
    #####:  114:	}
        1:  115:	clnt_cnt--;
        -:  116:
        1:  117:	if(clnt_cnt == 0)
branch  0 taken 1
branch  1 taken 0
        -:  118:	{
        1:  119:		game_start = 0;
        1:  120:		usr_cnt = 0;
        1:  121:	}
        1:  122:	pthread_mutex_unlock(&mutx);
        1:  123:	close(sock);
        -:  124:
        -:  125:	int end_thread;
        1:  126:	pthread_exit((void *)&end_thread);
        -:  127:
        -:  128:	
        -:  129:}
        -:  130:
        -:  131://write_byte: write datas to socket, guarantee that all the byte is sent. 
function write_byte called 67 returned 100% blocks executed 86%
       67:  132:int write_byte(int sock, void * buf, int size)
        -:  133:{
        -:  134:
       67:  135:	int write_size = 0;
       67:  136:	int str_len = 0;
      268:  137:	while(write_size < size)
branch  0 taken 67
branch  1 taken 67
        -:  138:	{
       67:  139:		str_len = write(sock, buf + write_size, size - write_size);
       67:  140:		if(str_len == -1)
branch  0 taken 0
branch  1 taken 67
        -:  141:		{
    #####:  142:			perror("write: ");
    #####:  143:			return 0;
        -:  144:		}
       67:  145:		write_size += str_len;
        -:  146:	}
       67:  147:	return write_size;
       67:  148:}
        -:  149:
        -:  150://read_byte: read datas from socket, guarantee that all byte is accepted.
function read_byte called 64 returned 100% blocks executed 100%
       64:  151:int read_byte(int sock, void * buf, int size)
        -:  152:{
       64:  153:	int read_size = 0;
       64:  154:	int str_len = 0;
      254:  155:	while(read_size < size)
branch  0 taken 64
branch  1 taken 63
        -:  156:	{
       64:  157:		str_len = read(sock, buf + read_size, size - read_size);
      127:  158:		if( str_len == 0 || str_len == -1)
branch  0 taken 63
branch  1 taken 1
branch  2 taken 0
branch  3 taken 63
        -:  159:		{
        1:  160:			disconnected(sock);
        1:  161:			return 0;
        -:  162:		}
       63:  163:		read_size += str_len;
        -:  164:	}
       63:  165:	return read_size;
       64:  166:}
        -:  167:
        -:  168://send_msg_all: send msg to all connected users
function send_msg_all called 61 returned 100% blocks executed 100%
       61:  169:void send_msg_all(void * event, int len)
        -:  170:{
       61:  171:	pthread_mutex_lock(&mutx);
      244:  172:	for (int i = 0; i < clnt_cnt; i++)
branch  0 taken 61
branch  1 taken 61
        -:  173:	{
       61:  174:		write_byte(clnt_socks[i], event, len);
       61:  175:	}
       61:  176:	pthread_mutex_unlock(&mutx);
       61:  177:}
        -:  178:
        -:  179://handle_clnt: thread function; handle one client per one thread. send json datas and recv commands, broadcast it to all... 
function handle_clnt called 1 returned 100% blocks executed 79%
        1:  180:void *handle_clnt(void * arg)
        -:  181:{
        1:  182:	int clnt_sock = *((int*)arg);
        1:  183:	int str_len = 0;
        -:  184:	int event;
        1:  185:	int name_size = 0;
        -:  186:
        -:  187:	//recive name size
        1:  188:	str_len = read_byte(clnt_sock, (void *)&name_size, sizeof(int));
        -:  189:	//reciev name, send id
        1:  190:	pthread_mutex_lock(&mutx);
        2:  191:	for (int i = 0; i < clnt_cnt; i++) 
branch  0 taken 1
branch  1 taken 0
        -:  192:	{
        1:  193:		if (clnt_sock == clnt_socks[i])
branch  0 taken 1
branch  1 taken 0
        -:  194:		{
        1:  195:			read_byte(clnt_sock, (void *)user_name[i], name_size);
        1:  196:			printf("%s is enter\n",user_name[i]);
        1:  197:			write_byte(clnt_sock, (void *)&i, sizeof(int));
        1:  198:			usr_cnt++;
        1:  199:			break;
        -:  200:		}
    #####:  201:	}
        1:  202:	pthread_mutex_unlock(&mutx);
        -:  203:
        -:  204:	//send json
        1:  205:	write_byte(clnt_sock, (void *)&json_size, sizeof(int));
        1:  206:	write_byte(clnt_sock, json_serialize, json_size);
        -:  207:
        2:  208:	while(usr_cnt < max_user); //wait untill all user is connected
branch  0 taken 0
branch  1 taken 1
        -:  209:	
        -:  210:	//send connected user information
        4:  211:	for(int i=0; i< max_user; i++)
branch  0 taken 1
branch  1 taken 1
        -:  212:	{
        1:  213:		int len = strlen(user_name[i]);
        1:  214:		write_byte(clnt_sock, &len,sizeof(int));
        1:  215:		write_byte(clnt_sock,user_name[i], len);
        1:  216:	}
        -:  217:
        -:  218:	//receive and echo command
      124:  219:	while (read_byte(clnt_sock, (void *)&event, sizeof(int))) 
branch  0 taken 61
branch  1 taken 1
        -:  220:	{
       61:  221:		printf("move: %d\n", event);
       61:  222:		send_msg_all((void *)&event, sizeof(int));
        -:  223:		//detect end flag
       61:  224:		if(event == max_user*4)
branch  0 taken 0
branch  1 taken 61
        -:  225:		{
    #####:  226:			printf("end game!\n");
    #####:  227:			disconnected(clnt_sock);
    #####:  228:		}
        -:  229:	}
        -:  230:	
        1:  231:	return NULL;
        -:  232:}
        -:  233:
        -:  234://error_handling: print error message
function error_handling called 0 returned 0% blocks executed 0%
    #####:  235:void error_handling(char * msg)
        -:  236:{
    #####:  237:	fputs(msg, stderr);
    #####:  238:	fputc('\n', stderr);
    #####:  239:	exit(1);
        -:  240:}
        -:  241:
        -:  242:int serv_sock;
function alarm_handler called 1 returned 100% blocks executed 100%
        1:  243:void alarm_handler(){
        1:  244:	free(json_serialize);
        1:  245:        close(serv_sock);
        1:  246:	exit(0);
        -:  247:}
        -:  248:
        -:  249://this is MAIN function
function main called 0 returned 0% blocks executed 21%
    #####:  250:int main(int argc, char *argv[])
        -:  251:{
        -:  252:	int clnt_sock;
        -:  253:	struct sockaddr_in serv_adr, clnt_adr;
        -:  254:	unsigned int clnt_adr_sz;
        -:  255:	pthread_t t_id;
    #####:  256:	if (argc != 2) {
branch  0 never executed
branch  1 never executed
    #####:  257:		printf("Usage : %s <port>\n", argv[0]);
    #####:  258:		exit(1);
        -:  259:	}
        -:  260:	
    #####:  261:	if(loadJson()) //parsing error return 1.
branch  0 never executed
branch  1 never executed
    #####:  262:		exit(1);
        -:  263:
    #####:  264:	pthread_mutex_init(&mutx, NULL);
    #####:  265:	serv_sock = socket(PF_INET, SOCK_STREAM, 0);
        -:  266:
    #####:  267:	memset(&serv_adr, 0, sizeof(serv_adr));
    #####:  268:	serv_adr.sin_family = AF_INET; 
    #####:  269:	serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
    #####:  270:	serv_adr.sin_port = htons(atoi(argv[1]));
        -:  271:	
    #####:  272:	if (bind(serv_sock, (struct sockaddr*) &serv_adr, sizeof(serv_adr)) == -1)
branch  0 never executed
branch  1 never executed
    #####:  273:		error_handling("bind() error");
        -:  274:	
    #####:  275:	if (listen(serv_sock, 5) == -1)
branch  0 never executed
branch  1 never executed
    #####:  276:		error_handling("listen() error");
    #####:  277:	signal(SIGALRM, alarm_handler);
    #####:  278:	alarm(20);
        1:  279:	while (1)
        -:  280:	{
        1:  281:		clnt_adr_sz = sizeof(clnt_adr);
        1:  282:		clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_sz);
        -:  283:		
        1:  284:		write_byte(clnt_sock, (void *)&game_start, sizeof(int));
        1:  285:		if(game_start == 1) //게임 중 플래그 start 
branch  0 taken 0
branch  1 taken 1
        -:  286:		{
    #####:  287:			close(clnt_sock);
    #####:  288:			continue;
        -:  289:		}
        -:  290:
        1:  291:		pthread_mutex_lock(&mutx); 
        1:  292:		clnt_socks[clnt_cnt++] = clnt_sock;
        1:  293:		pthread_mutex_unlock(&mutx);
        -:  294:		
        1:  295:		pthread_create(&t_id, NULL, handle_clnt, (void*)&clnt_sock);
        1:  296:		pthread_detach(t_id);
        -:  297:
        1:  298:		if(clnt_cnt == max_user)
branch  0 taken 1
branch  1 taken 0
        1:  299:			game_start = 1;
        -:  300:		
        -:  301:	}
        -:  302:	free(json_serialize);
        -:  303:	close(serv_sock);
        -:  304:	return 0;
        -:  305:}
        -:  306:	
