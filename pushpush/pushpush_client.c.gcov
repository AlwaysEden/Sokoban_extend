        -:    0:Source:pushpush_client.c
        -:    0:Graph:pushpush_client.gcno
        -:    0:Data:pushpush_client.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <string.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <time.h>
        -:    5:#include <gtk/gtk.h>
        -:    6:#include <unistd.h> 
        -:    7:#include <arpa/inet.h>
        -:    8:#include <sys/socket.h>
        -:    9:#include <pthread.h>
        -:   10:#include <errno.h>
        -:   11:#include <sys/stat.h>
        -:   12:#include "../cJSON.h"
        -:   13:
        -:   14:#define NAME_SIZE 16
        -:   15:#define queue_size 20
        -:   16:#define BUF_SIZE 128
        -:   17:#define GDK_KEY_UP 65362
        -:   18:#define GDK_KEY_DOWN 65364
        -:   19:#define GDK_KEY_LEFT 65361
        -:   20:#define GDK_KEY_RIGHT 65363
        -:   21:
        -:   22://object data structures
        -:   23:typedef struct location{
        -:   24:    int x;
        -:   25:    int y;
        -:   26:} location_t;
        -:   27:
        -:   28:typedef struct user{
        -:   29:    char name[NAME_SIZE];
        -:   30:    int score;
        -:   31:    location_t base_loc;
        -:   32:    location_t user_loc;
        -:   33:}user_t;
        -:   34:
        -:   35:typedef struct object_data{
        -:   36:    int map_width;
        -:   37:	int map_height;
        -:   38:    int timeout;
        -:   39:    int max_user;
        -:   40:    struct user * users;
        -:   41:    location_t * item_locations;
        -:   42:    location_t * block_locations;
        -:   43:}object_data_t;
        -:   44:
        -:   45:enum entity {
        -:   46:	EMPTY = 0,
        -:   47:	BLOCK = -1,
        -:   48:	ITEM = -9, //item will be -10 ~ -110
        -:   49:	USER = 1, //user wil be 1 ~ 3
        -:   50:	BASE = 9, //base will be 10 ~ 30
        -:   51:};
        -:   52:
        -:   53:enum spans {
        -:   54:	UP, 
        -:   55:	DOWN, 
        -:   56:	LEFT, 
        -:   57:	RIGHT
        -:   58:};
        -:   59:
        -:   60:char user_color[8][20] = {"#faa8a1", "#ffe479", "#dbe87c", "#a19b8b", "#ea9574", "#ffca79", "#c79465", "#e3dbcf"};
        -:   61:
        -:   62:int ** map; // cell
        -:   63:object_data_t Model; //model
        -:   64:char msg_info[BUF_SIZE] = "";
        -:   65:char buf[BUF_SIZE] = "";
        -:   66:int sock;
        -:   67:int my_id;
        -:   68:int num_item, num_block;
        -:   69:int current_num_item;
        -:   70:
        -:   71:pthread_mutex_t mutx;
        -:   72:pthread_cond_t cond;
        -:   73:int event_arry[queue_size];
        -:   74:int rear = 0;
        -:   75:int front = 0;
        -:   76:
        -:   77:
        -:   78://GUI functions
        -:   79:GtkWidget *window;
        -:   80:GtkWidget *mat_main, *mat_changed_screen, *mat_board, *label_info, *label_me, *mat_fixed_screen, *mat_screen;
        -:   81:GtkWidget *mat_ans_btn, *mat_sol_btn;
        -:   82:GtkWidget *btn_solve, *btn_exit, *btn_next, *btn_prev;
        -:   83:GtkWidget *btn_auto, *btn_up, *btn_down, *btn_left, *btn_right;
        -:   84:GtkWidget *label_name;
        -:   85:GtkWidget ** label_score; 
        -:   86:GdkPixbuf *icon, *icon_block[2], *icon_fruit[11];
        -:   87:GdkPixbuf ** icon_player;
        -:   88:GdkPixbuf *create_pixbuf(const gchar * filename);
        -:   89:GtkWidget* create_entity(int id);
        -:   90:int load_icons();
        -:   91:int check_map_valid();
        -:   92:void set_window();
        -:   93:static gboolean on_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data);
        -:   94:void display_screen();
        -:   95:void add_mat_board();
        -:   96:void exit_game(GtkWidget* widget);
        -:   97:void gameover();
        -:   98:
        -:   99://for move handling
        -:  100:int check_validation(int cmd);
        -:  101:int move(int cmd, int movement);
        -:  102:void update_model(int id, int x, int y);
        -:  103:void update_cell();
        -:  104:int item_idxToId(int idx);
        -:  105:int item_idToIdx(int id);
        -:  106:void score_up(int user_idx);
        -:  107:gboolean handle_cmd(gpointer user_data) ;
        -:  108:
        -:  109://for networking
        -:  110:int read_bytes(int sock_fd, void * buf, size_t len);
        -:  111:int write_bytes(int sock_fd, void * buf, size_t len);
        -:  112:void handle_timeout(int signum);
        -:  113:int parseJson(char * jsonfile);
        -:  114:void *read_msg(void * arg);
        -:  115:void cannot_enter();
        -:  116:
        -:  117:
        -:  118://this is MAIN
function main called 2 returned 100% blocks executed 65%
        2:  119:int main(int argc, char *argv[]) {
        -:  120:
        -:  121:	//get the username from stdin 
        -:  122:	//TODO maybe need change to args
        2:  123:	pthread_mutex_init(&mutx, NULL);
        2:  124:	pthread_cond_init(&cond, NULL);
        -:  125:
        2:  126:	signal(SIGALRM, handle_timeout);
        2:  127:	gtk_init(&argc, &argv); //init GTK by args
        -:  128:
        -:  129:	struct sockaddr_in serv_addr;
        -:  130:	pthread_t snd_thread, rcv_thread;
        -:  131:	void * thread_return;
        -:  132:
        2:  133:	if (argc != 3) {
branch  0 taken 0
branch  1 taken 2
    #####:  134:		printf("Usage : %s <IP> <port>\n", argv[0]);
    #####:  135:		exit(1);
        -:  136:	 }
        2:  137:	sock = socket(PF_INET, SOCK_STREAM, 0);
        -:  138:	
        2:  139:	memset(&serv_addr, 0, sizeof(serv_addr));
        2:  140:	serv_addr.sin_family = AF_INET;
        2:  141:	serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
        2:  142:	serv_addr.sin_port = htons(atoi(argv[2]));
        -:  143:	  
        2:  144:	if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
branch  0 taken 0
branch  1 taken 2
        -:  145:	{
    #####:  146:		fprintf(stderr, "ERROR: connect() error\n");
    #####:  147:		exit(1);
        -:  148:	}
        -:  149:
        -:  150:	int game_started;
        2:  151:	if (read_bytes(sock, (void*)&game_started, sizeof(int)) == -1) 
branch  0 taken 0
branch  1 taken 2
    #####:  152:    	return 1;
        -:  153:
        2:  154:	if(game_started){
branch  0 taken 0
branch  1 taken 2
    #####:  155:		cannot_enter();
    #####:  156:		close(sock);
    #####:  157:		return 0;
        -:  158:	}
        -:  159:	
        2:  160:	while(1){
        2:  161:		printf("enter your name: ");
        2:  162:		scanf("%s", buf);
        2:  163:		if(strlen(buf) > NAME_SIZE){
branch  0 taken 0
branch  1 taken 2
    #####:  164:			printf("invalid name. please pick another one.");	
    #####:  165:			continue;
        2:  166:		}else break;
        -:  167:	}
        -:  168:	
        2:  169:	int name_size = strlen(buf);
        2:  170:	if(write_bytes(sock, (void *)&name_size, sizeof(int)) == -1)
branch  0 taken 0
branch  1 taken 2
    #####:  171:		return 1;
        -:  172:
        2:  173:	if(write_bytes(sock, buf, strlen(buf)) == -1)
branch  0 taken 0
branch  1 taken 2
    #####:  174:		return 1;
        -:  175:
        -:  176:    //read my id
        2:  177:	if (read_bytes(sock, (void*)&my_id, sizeof(int)) == -1) 
branch  0 taken 0
branch  1 taken 2
    #####:  178:    	return 1;
        -:  179:		
        2:  180:	fprintf(stderr, "id : %d\n", my_id);
        -:  181:	
        -:  182:    // read json file
        -:  183:    int json_size;
        2:  184:    if (read_bytes(sock, (void*)&(json_size), sizeof(int)) == -1)
branch  0 taken 0
branch  1 taken 2
    #####:  185:		return 1;
        -:  186:
        2:  187:    char * json_format = malloc(sizeof(char) * json_size);
        2:  188:    if (read_bytes(sock, json_format, json_size) == -1)
branch  0 taken 0
branch  1 taken 2
    #####:  189:		return 1;
        -:  190:
        2:  191:	if(parseJson(json_format))
branch  0 taken 0
branch  1 taken 2
    #####:  192:		return 1;
        -:  193:	
        -:  194:	// receive all player's name size, name 
        -:  195:	// test hardcoding
        8:  196:	for (int i = 0; i < Model.max_user; i++) {
branch  0 taken 2
branch  1 taken 2
        -:  197:		int name_size;
        2:  198:		if (read_bytes(sock, (void*)&(name_size), sizeof(name_size)) == -1)
branch  0 taken 0
branch  1 taken 2
    #####:  199:			return 1;
        -:  200:	
        2:  201:		if (read_bytes(sock, (void*)(Model.users[i].name), name_size) == -1)
branch  0 taken 0
branch  1 taken 2
    #####:  202:			return 1;
        2:  203:		Model.users[i].name[name_size] = 0x0;
        2:  204:		printf("id : %d name : %s\n",i,Model.users[i].name);
        2:  205:	}
        -:  206:
        -:  207:
        2:  208:	map = (int **) malloc (sizeof(int *) * Model.map_width);
       44:  209:	for(int i=0;i<Model.map_width;i++){
branch  0 taken 20
branch  1 taken 2
       20:  210:		map[i] =(int *) malloc(sizeof(int) * Model.map_height);
       20:  211:	} 
        -:  212:
        2:  213:	label_score = (GtkWidget **) malloc(Model.max_user* sizeof(GtkWidget *));
        2:  214:	icon_player = (GdkPixbuf **) malloc(Model.max_user * sizeof(GdkPixbuf *));
        -:  215:
        2:  216:	update_cell();
        -:  217:
        -:  218:	//load icons from icons dir
        2:  219:	if(load_icons()) {
branch  0 taken 0
branch  1 taken 2
    #####:  220:		fprintf(stderr,"failed to load icons\n");
    #####:  221:		return 1;
        -:  222:  	}
        -:  223:
        2:  224:	srand((unsigned int)time(0));
        2:  225:	set_window();
        -:  226:
        2:  227:	alarm(Model.timeout);
        -:  228:
        2:  229:	pthread_create(&rcv_thread, NULL, read_msg, (void*)&sock);
        2:  230:	g_timeout_add(50,handle_cmd, NULL);
        -:  231:	
        2:  232:  	gtk_main(); //enter the GTK main loop
        -:  233:
        2:  234:	pthread_join(rcv_thread, &thread_return);
        2:  235:	free(map);
        2:  236:	close(sock);  
        2:  237:	pthread_mutex_destroy(&mutx);
        -:  238:
        2:  239: 	return 0;
        2:  240:}
        -:  241:
        -:  242:
        -:  243://get pixbuf(for load image) from filename
function create_pixbuf called 32 returned 100% blocks executed 67%
       32:  244:GdkPixbuf *create_pixbuf(const gchar * filename) {
        -:  245:   GdkPixbuf *pixbuf;
       32:  246:   GError *error = NULL;
       32:  247:   pixbuf = gdk_pixbuf_new_from_file(filename, &error);
       32:  248:   if (!pixbuf) {
branch  0 taken 0
branch  1 taken 32
    #####:  249:      fprintf(stderr, "%s\n", error->message);
    #####:  250:      g_error_free(error);
    #####:  251:   }
       32:  252:   return pixbuf;
        -:  253:}
        -:  254:
        -:  255:
        -:  256://load icons needed
        -:  257://0 on success, 1 on failure
function load_icons called 2 returned 100% blocks executed 87%
        2:  258:int load_icons(){
        -:  259:   	GdkPixbuf *pixbuf;
        8:  260:	for(int i = 0; i < Model.max_user; i++){
branch  0 taken 2
branch  1 taken 2
        2:  261:		sprintf(buf, "../icons/user%d.png", i);
        2:  262:		if((pixbuf = create_pixbuf(buf)) == NULL) return 1;
branch  0 taken 0
branch  1 taken 2
        2:  263:		else fprintf(stderr,"loading %s...\n", buf);
        2:  264:		icon_player[i] = gdk_pixbuf_scale_simple(pixbuf, 32, 32, GDK_INTERP_BILINEAR);
        2:  265:		g_object_unref(pixbuf);
        2:  266:	}
       12:  267:	for(int i = 0; i < 2; i++){
branch  0 taken 4
branch  1 taken 2
        4:  268:		sprintf(buf, "../icons/block%d.png", i);
        4:  269:		if((pixbuf = create_pixbuf(buf)) == NULL) return 1;
branch  0 taken 0
branch  1 taken 4
        4:  270:		else fprintf(stderr,"loading %s...\n", buf);
        4:  271:		icon_block[i] = gdk_pixbuf_scale_simple(pixbuf, 32, 32, GDK_INTERP_BILINEAR);
        4:  272:		g_object_unref(pixbuf);
        4:  273:	}
       52:  274:	for(int i = 0; i < 12; i++){
branch  0 taken 24
branch  1 taken 2
       24:  275:		sprintf(buf, "../icons/fruit%d.png", i);
       24:  276:		if((pixbuf = create_pixbuf(buf)) == NULL) return 1;
branch  0 taken 0
branch  1 taken 24
       24:  277:		else fprintf(stderr,"loading %s...\n", buf);
       24:  278:		icon_fruit[i] = gdk_pixbuf_scale_simple(pixbuf, 32, 32, GDK_INTERP_BILINEAR);
       24:  279:		g_object_unref(pixbuf);
       24:  280:	}
        -:  281:
        2:  282:	fprintf(stderr,"success to load all icons!\n");
        2:  283:	return 0;
        -:  284:
        2:  285:}
        -:  286:
        -:  287://GUI: set the main window
function set_window called 2 returned 100% blocks executed 100%
        2:  288:void set_window(){
        -:  289:
        2:  290:  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);//make window
        2:  291:  g_signal_connect(window, "destroy", G_CALLBACK(gtk_main_quit), NULL);//for termination
        2:  292:  g_signal_connect(G_OBJECT(window), "key-press-event", G_CALLBACK(on_key_press), NULL);
        -:  293: 
        -:  294:  //set the window
        2:  295:  gtk_window_set_title(GTK_WINDOW(window), "pushpush HK");
        2:  296:  gtk_window_set_default_size(GTK_WINDOW(window), 1024, 512);
        2:  297:  gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
        2:  298:  gtk_container_set_border_width(GTK_CONTAINER(window), 5);
        -:  299:
        -:  300:  //change the icon of page(for cuteness)
        2:  301:  icon = create_pixbuf("../icons/catIcon.png");
        2:  302:  gtk_window_set_icon(GTK_WINDOW(window), icon);
        -:  303:  
        -:  304:  //set main matrix
        2:  305:  mat_main = gtk_table_new(8, 8-1, TRUE);
        -:  306:	
        2:  307:  strcpy(msg_info, "Welcome to PushPush HK!");
        2:  308:  label_info = gtk_label_new(msg_info);
        2:  309:  gtk_table_attach_defaults(GTK_TABLE(mat_main), label_info, 0, 11, 0, 1);
        -:  310:  
        2:  311:  display_screen();
        2:  312:  add_mat_board();
        -:  313: 
        2:  314:  label_me = gtk_label_new("23-winter capston study#2 leeejjju");
        2:  315:  gtk_misc_set_alignment(GTK_MISC(label_me), 0.0, 1.0);
        2:  316:  gtk_table_attach_defaults(GTK_TABLE(mat_main), label_me, 0, 8+1, 6, 8);
        -:  317:
        2:  318:  gtk_container_add(GTK_CONTAINER(window), mat_main);
        2:  319:  gtk_widget_show_all(window); //is it dup with above
        2:  320:  g_object_unref(icon);
        -:  321:
        -:  322:
        2:  323:}
        -:  324:
        -:  325://create entity Widget from ids, return widget* or NULL on id-empty
function create_entity called 23700 returned 100% blocks executed 100%
    23700:  326:GtkWidget* create_entity(int id){
        -:  327:
        -:  328:	GtkWidget* sprite;
        -:  329:	GdkColor color;
        -:  330:	int idx;
        -:  331:
    46491:  332:	if(id == EMPTY) return NULL;
branch  0 taken 22791
branch  1 taken 909
      909:  333:	else if(id == BLOCK){
branch  0 taken 10
branch  1 taken 899
       10:  334:		idx = rand() % 2;
       10:  335:      	sprite = gtk_image_new_from_pixbuf(icon_block[idx]); 
      909:  336:	}else if(id < ITEM){
branch  0 taken 648
branch  1 taken 251
      648:  337:		idx = (0-id)/10-1;
      648:  338:      	sprite = gtk_image_new_from_pixbuf(icon_fruit[idx]); 
      899:  339:	}else if(id > BASE){
branch  0 taken 2
branch  1 taken 249
        2:  340:		idx = id/10 -1;
        2:  341:		sprite = gtk_event_box_new();
        -:  342:		//gtk_widget_set_size_request(sprite, 32, 32);		
        2:  343:		gdk_color_parse(user_color[idx], &color);
        2:  344:		gtk_widget_modify_bg(sprite, GTK_STATE_NORMAL, &color);
        2:  345:	}else{
      249:  346:		idx = id-1;
      249:  347:      	sprite = gtk_image_new_from_pixbuf(icon_player[idx]); 
        -:  348:	}
      909:  349:	return sprite;
        -:  350:
    23700:  351:}
        -:  352:
        -:  353://GUI: display screen from map[] model
function display_screen called 252 returned 100% blocks executed 100%
      252:  354:void display_screen(){
        -:  355:	
        -:  356:  //set screen matrix
      252:  357:  if(mat_changed_screen == NULL){ //initially once
branch  0 taken 2
branch  1 taken 250
        2:  358:	mat_screen = gtk_fixed_new();
        2:  359:	mat_changed_screen = gtk_table_new(Model.map_width, Model.map_height, TRUE);
        2:  360:	mat_fixed_screen = gtk_table_new(Model.map_width, Model.map_height, TRUE);
       44:  361:  for (int i = 0; i < Model.map_width; i++) {
branch  0 taken 20
branch  1 taken 2
      440:  362:    for (int j = 0; j < Model.map_height; j++) {
branch  0 taken 200
branch  1 taken 20
      390:  363:			if(map[j][i] == BLOCK || map[j][i] > BASE){
branch  0 taken 190
branch  1 taken 10
branch  2 taken 2
branch  3 taken 188
       12:  364:				GtkWidget* sprite = create_entity(map[j][i]);
       24:  365:				if(sprite != NULL) gtk_table_attach_defaults(GTK_TABLE(mat_fixed_screen), sprite, i, i+1, j, j+1);
branch  0 taken 12
branch  1 taken 0
       12:  366:			}	
      200:  367:		}
       20:  368:  }
        2:  369:	gtk_fixed_put(GTK_FIXED(mat_screen), mat_fixed_screen, 0, 0);
        2:  370:	gtk_fixed_put(GTK_FIXED(mat_screen), mat_changed_screen, 0, 0);
      252:  371:  }else gtk_container_foreach(GTK_CONTAINER(mat_changed_screen), (GtkCallback)gtk_widget_destroy, NULL); 
        -:  372:
     5544:  373:  for (int i = 0; i < Model.map_width; i++) {
branch  0 taken 2520
branch  1 taken 252
    55440:  374:    for (int j = 0; j < Model.map_height; j++) {
branch  0 taken 25200
branch  1 taken 2520
    49140:  375:		if(map[j][i] == BLOCK || map[j][i] > BASE) 
branch  0 taken 23940
branch  1 taken 1260
branch  2 taken 252
branch  3 taken 23688
     1512:  376:			continue;
    23688:  377:		GtkWidget* sprite = create_entity(map[j][i]);
    24585:  378:		if(sprite != NULL) gtk_table_attach_defaults(GTK_TABLE(mat_changed_screen), sprite, i, i+1, j, j+1);
branch  0 taken 897
branch  1 taken 22791
    23688:  379:    }
     2520:  380:  }
        -:  381:
      254:  382:  if(!gtk_widget_get_parent(mat_screen)) gtk_table_attach_defaults(GTK_TABLE(mat_main), mat_screen, 0, 9, 1, 10);
branch  0 taken 2
branch  1 taken 250
      252:  383:  gtk_widget_show_all(window); 
        -:  384:
      252:  385:}
        -:  386:
        -:  387://GUI: set the score board
function add_mat_board called 2 returned 100% blocks executed 100%
        2:  388:void add_mat_board(){
        -:  389:
        -:  390:  //set board vbox
        2:  391:  int board_width = 8;
        2:  392:  mat_board = gtk_table_new(board_width, 10, TRUE);
        -:  393:
        2:  394:  GtkWidget* line1 = gtk_hseparator_new();
        2:  395:  sprintf(buf, "Good luck, %s!", Model.users[my_id].name);
        2:  396:  label_name = gtk_label_new(buf);
        2:  397:  GtkWidget* sprite = gtk_image_new_from_pixbuf(icon_player[my_id]);
        2:  398:  GtkWidget* line2 = gtk_hseparator_new();
        2:  399:  GtkWidget *label_title = gtk_label_new(":: SCORE ::");
        -:  400:  
        2:  401:  gtk_table_attach_defaults(GTK_TABLE(mat_board), line1, 0, board_width+1, 0, 1);
        2:  402:  gtk_table_attach_defaults(GTK_TABLE(mat_board), label_name, 0, board_width+1, 1, 2);
        2:  403:  gtk_table_attach_defaults(GTK_TABLE(mat_board), line2, 0, board_width+1, 2, 3);
        2:  404:  gtk_table_attach_defaults(GTK_TABLE(mat_board), sprite, 0, board_width+1, 3, 4);
        2:  405:  gtk_table_attach_defaults(GTK_TABLE(mat_board), label_title, 0, board_width+1, 4, 5);
        -:  406:	
        2:  407:  GtkWidget* score_board = gtk_vbox_new(TRUE, 10);
        8:  408:  for(int i = 0; i < Model.max_user; i++){
branch  0 taken 2
branch  1 taken 2
        2:  409:	sprintf(msg_info, "%s: %d", Model.users[i].name, Model.users[i].score);		
        2:  410:	label_score[i] = gtk_label_new(msg_info);
        2:  411:	gtk_container_add(GTK_CONTAINER(score_board), label_score[i]);
        2:  412:  } 
        2:  413:  gtk_container_add(GTK_CONTAINER(score_board), gtk_label_new(""));
        2:  414:  gtk_table_attach_defaults(GTK_TABLE(mat_board), score_board, 0, board_width+1, 5, 10);
        -:  415:
        2:  416:  btn_exit = gtk_button_new_with_label("exit game");
        2:  417:  gtk_table_attach_defaults(GTK_TABLE(mat_board), btn_exit, 0, board_width+1, 10, 11);
        2:  418:  g_signal_connect(G_OBJECT(btn_exit), "clicked", G_CALLBACK(exit_game), NULL);
        2:  419:  gtk_table_attach_defaults(GTK_TABLE(mat_main), mat_board, 9, 11, 0, 8); 
        -:  420:
        2:  421:}
        -:  422:
function exit_game called 2 returned 100% blocks executed 100%
        2:  423:void exit_game(GtkWidget* widget){
        2:  424:	printf("See you again!\n");
        2:  425:	exit(EXIT_SUCCESS);
        -:  426:}
        -:  427:
        -:  428:
function check_validation called 317 returned 100% blocks executed 56%
      317:  429:int check_validation(int cmd){
      317:  430:	int user_idx = cmd/4;
      317:  431:	int span = cmd%4;	
        -:  432:	
        -:  433:	int curr_x, curr_y, target_x, target_y, item_target_x, item_target_y;
      317:  434:	curr_x = target_x = item_target_x = Model.users[user_idx].user_loc.x;
      317:  435:	curr_y = target_y = item_target_y = Model.users[user_idx].user_loc.y;
      317:  436:	switch(span){
branch  0 taken 71
branch  1 taken 65
branch  2 taken 65
branch  3 taken 55
branch  4 taken 61
        -:  437:		case UP:		
       73:  438:			if((target_y = (curr_y - 1)) < 0) return 0;//out of array
branch  0 taken 2
branch  1 taken 69
      134:  439:			else if(map[target_y][target_x] == EMPTY) return 1; //empty
branch  0 taken 65
branch  1 taken 4
        4:  440:			else if(map[target_y][target_x] > BASE) return 1; //base
branch  0 taken 0
branch  1 taken 4
        4:  441:			else if(map[target_y][target_x] < ITEM){ 
branch  0 taken 4
branch  1 taken 0
        4:  442:				if((item_target_y = (target_y - 1)) < 0) return 0; //item and non-movabel
branch  0 taken 0
branch  1 taken 4
        8:  443:				if(map[item_target_y][item_target_x] == EMPTY) return map[target_y][target_x]; //item and movable
branch  0 taken 4
branch  1 taken 0
    #####:  444:				if((map[item_target_y][item_target_x] > BASE) && ((map[item_target_y][item_target_x]) == ((user_idx + 1) * 10))) return (0 - map[target_y][target_x]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  445:				if(map[item_target_y][item_target_x] > BASE) return map[target_y][target_x]; //item and movable as other's base
branch  0 never executed
branch  1 never executed
    #####:  446:				else return 0;	//others (block, user, base)
    #####:  447:			}else return 0;	
        -:  448:			break;
        -:  449:
        -:  450:		case DOWN:
       65:  451:			if((target_y = (curr_y + 1)) > Model.map_height -1 ) return 0;//out of array
branch  0 taken 0
branch  1 taken 65
       84:  452:			else if(map[target_y][target_x] == EMPTY) return 1; //empty
branch  0 taken 19
branch  1 taken 46
       47:  453:			else if(map[target_y][target_x] > BASE) return 1; //base
branch  0 taken 1
branch  1 taken 45
       45:  454:			else if(map[target_y][target_x] < ITEM){ 
branch  0 taken 45
branch  1 taken 0
       45:  455:				if((item_target_y = (target_y + 1)) > Model.map_height - 1) return 0; //item and non-movabel
branch  0 taken 0
branch  1 taken 45
       81:  456:				if(map[item_target_y][item_target_x] == EMPTY) return map[target_y][target_x]; //item and movable
branch  0 taken 36
branch  1 taken 9
       27:  457:				if((map[item_target_y][item_target_x] > BASE) && ((map[item_target_y][item_target_x]) == ((user_idx + 1) * 10))) return (0 - map[target_y][target_x]);
branch  0 taken 9
branch  1 taken 0
branch  2 taken 9
branch  3 taken 0
    #####:  458:				if(map[item_target_y][item_target_x] > BASE) return map[target_y][target_x]; //item and movable as other's base
branch  0 never executed
branch  1 never executed
    #####:  459:				else return 0;	//others (block, user, base)
    #####:  460:			}else return 0;	
        -:  461:			break;
        -:  462:
        -:  463:
        -:  464:		case LEFT:
       66:  465:			if((target_x = (curr_x - 1)) < 0) return 0;//out of array
branch  0 taken 1
branch  1 taken 64
      123:  466:			else if(map[target_y][target_x] == EMPTY) return 1; //empty
branch  0 taken 59
branch  1 taken 5
        5:  467:			else if(map[target_y][target_x] > BASE) return 1; //base
branch  0 taken 0
branch  1 taken 5
        5:  468:			else if(map[target_y][target_x] < ITEM){ 
branch  0 taken 2
branch  1 taken 3
        2:  469:				if((item_target_x = (target_x - 1)) < 0) return 0; //item and non-movabel
branch  0 taken 0
branch  1 taken 2
        4:  470:				if(map[item_target_y][item_target_x] == EMPTY) return map[target_y][target_x]; //item and movable
branch  0 taken 2
branch  1 taken 0
    #####:  471:				if((map[item_target_y][item_target_x] > BASE) && ((map[item_target_y][item_target_x]) == ((user_idx + 1)  * 10))) return (0 - map[target_y][target_x]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  472:				if(map[item_target_y][item_target_x] > BASE) return map[target_y][target_x]; //item and movable as other's base
branch  0 never executed
branch  1 never executed
        -:  473:
    #####:  474:				else return 0;	//others (block, user, base)
        3:  475:			}else return 0;	
        -:  476:			break;
        -:  477:
        -:  478:		case RIGHT:
       55:  479:			if((target_x = (curr_x + 1)) > Model.map_width  - 1) return 0;//out of array
branch  0 taken 0
branch  1 taken 55
       84:  480:			else if(map[target_y][target_x] == EMPTY) return 1; //empty
branch  0 taken 29
branch  1 taken 26
       26:  481:			else if(map[target_y][target_x] > BASE) return 1; //base
branch  0 taken 0
branch  1 taken 26
       26:  482:			else if(map[target_y][target_x] < ITEM){ 
branch  0 taken 26
branch  1 taken 0
       26:  483:				if((item_target_x = (target_x + 1)) > Model.map_width -1) return 0; //item and non-movabel
branch  0 taken 0
branch  1 taken 26
       52:  484:				if(map[item_target_y][item_target_x] == EMPTY) return map[target_y][target_x]; //item and movable
branch  0 taken 26
branch  1 taken 0
    #####:  485:				if((map[item_target_y][item_target_x] > BASE) && ((map[item_target_y][item_target_x]) == ((user_idx + 1) * 10))) return (0 - map[target_y][target_x]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  486:				if(map[item_target_y][item_target_x] > BASE) return map[target_y][target_x]; //item and movable as other's base
branch  0 never executed
branch  1 never executed
    #####:  487:				else return 0;	//others (block, user, base)
    #####:  488:			}else return 0;	
        -:  489:			break;
        -:  490:	}
       61:  491:	return 0;
      317:  492:}
        -:  493:
        -:  494://update cells by cmd(0-15), 
        -:  495://return 0 on normal moving, return 1 on get-score moving
        -:  496://TODO 
function move called 250 returned 100% blocks executed 100%
      250:  497:int move(int cmd, int movement){
      250:  498:	int user_idx = cmd/4;
      250:  499:	int span = cmd%4;	
        -:  500:	int curr_x, curr_y, target_x, target_y, item_target_x, item_target_y;
      250:  501:	curr_x = target_x = item_target_x = Model.users[user_idx].user_loc.x;
      250:  502:	curr_y = target_y = item_target_y = Model.users[user_idx].user_loc.y;
      250:  503:	switch(span){
branch  0 taken 69
branch  1 taken 65
branch  2 taken 61
branch  3 taken 55
branch  4 taken 0
        -:  504:		case UP:		
       69:  505:			target_y = curr_y - 1;
       69:  506:			item_target_y = target_y - 1;
       69:  507:			break;	
        -:  508:		case DOWN:
       65:  509:			target_y = curr_y + 1;
       65:  510:			item_target_y = target_y + 1;
       65:  511:			break;	
        -:  512:		case LEFT:
       61:  513:			target_x = curr_x - 1;
       61:  514:			item_target_x = target_x - 1;
       61:  515:			break;	
        -:  516:		case RIGHT:
       55:  517:			target_x = curr_x + 1;
       55:  518:			item_target_x = target_x + 1;
       55:  519:			break;	
        -:  520:	}
        -:  521:	
      250:  522:	if(movement < ITEM){ //valid and item-empty
branch  0 taken 68
branch  1 taken 182
       68:  523:		fprintf(stderr,"move for item %d!!!\n", movement);	
       68:  524:		update_model(movement, item_target_x, item_target_y);	
      250:  525:	}else if(movement > (0-ITEM)){ //valid and item-scoreup
branch  0 taken 9
branch  1 taken 173
        9:  526:		fprintf(stderr,"move for success %d!!!\n", movement);	
        9:  527:		update_model((0-movement), -1, -1);	
        9:  528:		score_up(user_idx);
        9:  529:		current_num_item--;
        9:  530:	}
      250:  531:	update_model(user_idx+1, target_x,target_y);	
      250:  532:	fprintf(stderr,"move finish!\n");
      250:  533:}
        -:  534:
function on_key_press called 431 returned 100% blocks executed 100%
      431:  535:gboolean on_key_press(GtkWidget *widget, GdkEventKey *event, gpointer user_data) {
        -:  536:    
      431:  537:	const gchar *greeting = NULL;
      431:  538:	int cmd = my_id*4;
      431:  539:    switch (event->keyval) {
branch  0 taken 112
branch  1 taken 109
branch  2 taken 110
branch  3 taken 100
branch  4 taken 0
        -:  540:        case GDK_KEY_UP:
      112:  541:            greeting = "up key pressed...";
      112:  542:			cmd += 0;
      112:  543:            break;
        -:  544:        case GDK_KEY_DOWN:
      109:  545:            greeting = "down key pressed...";
      109:  546:			cmd += 1;
      109:  547:            break;
        -:  548:        case GDK_KEY_LEFT:
      110:  549:            greeting = "left key pressed...";
      110:  550:			cmd += 2;
      110:  551:            break;
        -:  552:        case GDK_KEY_RIGHT:
      100:  553:            greeting = "right key pressed...";
      100:  554:			cmd += 3;
      100:  555:            break;
        -:  556:    }
      431:  557:	fprintf(stderr,"keyboard :%d player id : %d, cmd : %d\n", event->keyval, my_id ,cmd);
      431:  558:	write_bytes(sock, (void*)&cmd, sizeof(int));
        -:  559:
      431:  560:	return TRUE;
        -:  561:}
        -:  562:
function update_model called 327 returned 100% blocks executed 100%
      327:  563:void update_model(int id, int x, int y){
        -:  564:
      327:  565:	printf("update model\n");
        -:  566:
        -:  567:	int idx;
      327:  568:	if(id < ITEM){ //item
branch  0 taken 77
branch  1 taken 250
       77:  569:		idx = item_idToIdx(id);
       77:  570:		Model.item_locations[idx].x = x;	
       77:  571:		Model.item_locations[idx].y = y;	
       77:  572:		fprintf(stderr,"item model updated\n");
       77:  573:	}else{ //user
      250:  574:		idx = id - 1; 
      250:  575:		Model.users[idx].user_loc.x = x;	
      250:  576:		Model.users[idx].user_loc.y = y;	
      250:  577:		fprintf(stderr,"user model updated\n");
        -:  578:	}
      327:  579:	update_cell();
        -:  580:	//for debug
     7194:  581:	for (int i = 0; i < Model.map_width; i++) {
branch  0 taken 3270
branch  1 taken 327
    71940:  582:      for (int j = 0; j < Model.map_height; j++) {
branch  0 taken 32700
branch  1 taken 3270
    32700:  583:		fprintf(stderr,"%3d ",map[i][j]);
    32700:  584:	  }
     3270:  585:	  fprintf(stderr,"\n");
     3270:  586:    }
        -:  587:
      327:  588:}
        -:  589:
function update_cell called 329 returned 100% blocks executed 100%
      329:  590:void update_cell(){
        -:  591:
        -:  592:	//init
     7238:  593:	for(int i = 0; i < Model.map_width; i++){
branch  0 taken 3290
branch  1 taken 329
    72380:  594:		for(int j = 0; j < Model.map_height; j++){
branch  0 taken 32900
branch  1 taken 3290
    32900:  595:			map[j][i] = EMPTY;
    32900:  596:		}
     3290:  597:	}
        -:  598:
        -:  599:	//base and user
     1316:  600:	for(int i = 0; i < Model.max_user; i++){
branch  0 taken 329
branch  1 taken 329
      329:  601:		int id = i+1;
      329:  602:		map[Model.users[i].user_loc.y][Model.users[i].user_loc.x] = id;
      329:  603:		map[Model.users[i].base_loc.y][Model.users[i].base_loc.x] = id*10;
        -:  604:
      329:  605:		fprintf(stderr,"user %d  x : %d, y : %d, base %d, %d\n",i, Model.users[i].user_loc.x,Model.users[i].user_loc.y, Model.users[i].base_loc.x,Model.users[i].base_loc.y);
      329:  606:	}
        -:  607:	//block
     3948:  608:	for (int i = 0; i < num_block; i++) {
branch  0 taken 1645
branch  1 taken 329
     1645:  609:		map[Model.block_locations[i].y][Model.block_locations[i].x] = BLOCK;
     1645:  610:    }
        -:  611:
        -:  612:	//item
     4606:  613:	for (int i = 0; i < num_item; i++) {
branch  0 taken 1974
branch  1 taken 329
     1974:  614:		int item_id = item_idxToId(i);
     4102:  615:		if(Model.item_locations[i].x == -1 && Model.item_locations[i].y == -1) continue; //skip removed item
branch  0 taken 1064
branch  1 taken 910
branch  2 taken 1064
branch  3 taken 0
      910:  616:		map[Model.item_locations[i].y][Model.item_locations[i].x] = item_id;
      910:  617:    }
        -:  618:
      329:  619:}
function item_idxToId called 1974 returned 100% blocks executed 100%
     1974:  620:int item_idxToId(int idx){ return ((0-(idx+1))*10); } //0 -> -10
function item_idToIdx called 77 returned 100% blocks executed 100%
       77:  621:int item_idToIdx(int id){ return (((0-id)/10)-1); }//-10 -> 0
        -:  622:
        -:  623:
function score_up called 9 returned 100% blocks executed 100%
        9:  624:void score_up(int user_idx){
        -:  625:	
        9:  626:	Model.users[user_idx].score ++;
        9:  627:	sprintf(msg_info, "%s got the score!", Model.users[user_idx].name);
        9:  628:	fprintf(stderr,"%s got the score!\n", Model.users[user_idx].name);
        9:  629:	gtk_label_set_text((GtkLabel*)label_info, msg_info);
        9:  630:	sprintf(msg_info, "%s: %d", Model.users[user_idx].name, Model.users[user_idx].score);
        9:  631:	gtk_label_set_text((GtkLabel*)label_score[user_idx], msg_info);
        -:  632:
        9:  633:}
        -:  634:
function gameover called 73 returned 100% blocks executed 100%
       73:  635:void gameover(){
        -:  636:	
       73:  637:	sprintf(msg_info, "GAME OVER!!!");
       73:  638:	fprintf(stderr,"GAME OVER\n");
       73:  639:	gtk_label_set_text((GtkLabel*)label_info, msg_info);
        -:  640:
       73:  641:	gtk_widget_show_all(window);
       73:  642:}
        -:  643:
function parseJson called 2 returned 100% blocks executed 94%
        2:  644:int parseJson(char * jsonfile) {
        -:  645:
        -:  646:    cJSON* root;
        2:  647:	root = cJSON_Parse(jsonfile);
        2:  648:	if (root == NULL) {
branch  0 taken 0
branch  1 taken 2
    #####:  649:		printf("JSON parsing error: %s\n", cJSON_GetErrorPtr());
    #####:  650:        	return 1;
        -:  651:    	}
        -:  652:        
        2:  653:	cJSON* timeout = cJSON_GetObjectItem(root, "timeout");
        2:  654:	Model.timeout = timeout->valueint;
        2:  655:	cJSON* max_user = cJSON_GetObjectItem(root, "max_user");
        2:  656:	Model.max_user = max_user->valueint;
        -:  657:
        2:  658:	cJSON* map = cJSON_GetObjectItem(root, "map");
        2:  659:	cJSON* map_width = cJSON_GetObjectItem(map, "map_width");
        2:  660:	Model.map_width = map_width->valueint;	
        2:  661:	cJSON* map_height = cJSON_GetObjectItem(map, "map_height");
        2:  662:	Model.map_height = map_height->valueint;
        -:  663:
        2:  664:	cJSON* user = cJSON_GetObjectItem(root, "user");
        2:  665:	Model.users = (struct user *)malloc(sizeof(struct user) * Model.max_user);
        8:  666:	for(int i = 0; i < Model.max_user; i++){
branch  0 taken 2
branch  1 taken 2
        2:  667:		memset(Model.users[i].name, 0, sizeof(NAME_SIZE));
        2:  668:		Model.users[i].score = 0;
        2:  669:		cJSON* user_array = cJSON_GetArrayItem(user,i);
        2:  670:	    cJSON* base = cJSON_GetObjectItem(user_array,"base"); 
        2:  671:		cJSON* base_x = cJSON_GetArrayItem(base, 0);
        2:  672:		cJSON* base_y = cJSON_GetArrayItem(base, 1);
        2:  673:		cJSON* user_location = cJSON_GetObjectItem(user_array,"location"); 
        2:  674:		cJSON* user_x = cJSON_GetArrayItem(user_location, 0);
        2:  675:		cJSON* user_y = cJSON_GetArrayItem(user_location, 1);
        2:  676:		Model.users[i].user_loc.x = user_x->valueint;
        2:  677:		Model.users[i].user_loc.y = user_y->valueint;
        2:  678:		Model.users[i].base_loc.x = base_x->valueint;
        2:  679:		Model.users[i].base_loc.y = base_y->valueint;
        -:  680:	#ifdef DEBUG
        2:  681:		printf("name: %s\n",Model.users[i].name);
        2:  682:		printf("base x: %d\n",Model.users[i].base_loc.x);
        2:  683:		printf("base y: %d\n",Model.users[i].base_loc.y);
        -:  684:	#endif
        2:  685:	}
        -:  686:	
        2:  687:	cJSON * item = cJSON_GetObjectItem(root, "item_location");
        2:  688:	num_item = cJSON_GetArraySize(item);
        2:  689:	current_num_item = num_item;
        2:  690:	Model.item_locations = (struct location *)malloc(sizeof(struct location) * num_item); 
       28:  691:	for(int i = 0; i < num_item; i++){
branch  0 taken 12
branch  1 taken 2
       12:  692:		cJSON* item_array = cJSON_GetArrayItem(item,i);
       12:  693:		cJSON* item_x = cJSON_GetArrayItem(item_array, 0);
       12:  694:		cJSON* item_y = cJSON_GetArrayItem(item_array, 1);
       12:  695:		Model.item_locations[i].x = item_x->valueint;
       12:  696:		Model.item_locations[i].y = item_y->valueint;
        -:  697:	#ifdef DEBUG
       12:  698:		printf("item x: %d\n",Model.item_locations[i].x);
       12:  699:		printf("item y: %d\n",Model.item_locations[i].y);
        -:  700:		#endif
       12:  701:	}	
        -:  702:
        2:  703:	cJSON * block = cJSON_GetObjectItem(root, "block_location");
        2:  704:	num_block = cJSON_GetArraySize(block);
        2:  705:	Model.block_locations = (struct location *)malloc(sizeof(struct location) * num_block); 
       24:  706:	for(int i = 0; i < num_block; i++){
branch  0 taken 10
branch  1 taken 2
       10:  707:		cJSON* block_array = cJSON_GetArrayItem(block,i);
       10:  708:		cJSON* block_x = cJSON_GetArrayItem(block_array, 0);
       10:  709:		cJSON* block_y = cJSON_GetArrayItem(block_array, 1);
       10:  710:		Model.block_locations[i].x = block_x->valueint;
       10:  711:		Model.block_locations[i].y = block_y->valueint;
        -:  712:	#ifdef DEBUG
       10:  713:		printf("block x: %d\n",Model.block_locations[i].x);
       10:  714:		printf("block y: %d\n",Model.block_locations[i].y);
        -:  715:	#endif
       10:  716:	}	
        -:  717:		
        2:  718:	return 0;
        2:  719:}
        -:  720:
function handle_timeout called 1 returned 100% blocks executed 100%
        1:  721:void handle_timeout(int signum) {
        -:  722:    // 이 함수가 호출되면 10초가 경과했음을 의미
        1:  723:	int game_over = Model.max_user*4;
        -:  724:
        1:  725:	write_bytes(sock,(void *)&game_over,sizeof(game_over));
        -:  726:    //gameover 신호 보내기 
        1:  727:	gameover();
        1:  728:}
function read_msg called 2 returned 100% blocks executed 86%
        2:  729:void * read_msg(void * arg)   // read thread main
        -:  730:{
        2:  731:	int sock = *((int*)arg);
        -:  732:	int read_cmd;
        -:  733:
        -:  734:	//now enter new move 
      259:  735:	while(1){
      259:  736:		if(read_bytes(sock, (void *)&read_cmd, sizeof(read_cmd)) == -1)
branch  0 taken 2
branch  1 taken 257
        2:  737:			return (void*)-1;
        -:  738:
      257:  739:        fprintf(stderr, "From Server : %d\n", read_cmd);
        -:  740:
      257:  741:		pthread_mutex_lock(&mutx);
      514:  742:		while((rear+1)%queue_size == front)
branch  0 taken 0
branch  1 taken 257
    #####:  743:			pthread_cond_wait(&cond, &mutx);
      257:  744:		rear = (rear + 1) % queue_size;
      257:  745:		event_arry[rear] = read_cmd;
      257:  746:		pthread_cond_signal(&cond);
      257:  747:  		pthread_mutex_unlock(&mutx);
        -:  748:	}
        -:  749:	return NULL;
        -:  750:}
        -:  751:
function read_bytes called 270 returned 100% blocks executed 100%
      270:  752:int read_bytes(int sock_fd, void * buf, size_t len){
      270:  753:    char * p = (char *)buf;
      270:  754:    size_t acc = 0;
        -:  755:
     1078:  756:    while(acc < len)
branch  0 taken 270
branch  1 taken 269
        -:  757:    {
        -:  758:        size_t readed;
      270:  759:        readed = read(sock_fd, p, len - acc);
      540:  760:        if(readed  == -1 || readed == 0){
branch  0 taken 270
branch  1 taken 0
branch  2 taken 1
branch  3 taken 269
        1:  761:            return -1;
        -:  762:        }
      269:  763:        p+= readed ;
      269:  764:        acc += readed ;
        -:  765:    }
      269:  766:    return 0;
      270:  767:}
        -:  768:
function write_bytes called 436 returned 100% blocks executed 100%
      436:  769:int write_bytes(int sock_fd, void * buf, size_t len){
      436:  770:    char * p = (char *) buf;
      436:  771:    size_t acc = 0;
        -:  772:
     1396:  773:    while(acc < len){
branch  0 taken 436
branch  1 taken 262
        -:  774:        size_t sent;
      436:  775:        sent = write(sock_fd, p, len - acc);
      436:  776:        if(sent == -1){
branch  0 taken 174
branch  1 taken 262
      174:  777:            return -1;
        -:  778:        }
        -:  779:
      262:  780:        p+= sent;
      262:  781:        acc += sent;
        -:  782:    }
      262:  783:    return 0;
      436:  784:}
        -:  785:
function handle_cmd called 866 returned 100% blocks executed 100%
      866:  786:gboolean handle_cmd(gpointer user_data) {
        -:  787:	int event;
      866:  788:    pthread_mutex_lock(&mutx);
      866:  789:	if(rear == front)
branch  0 taken 609
branch  1 taken 257
        -:  790:	{
      609:  791:		pthread_mutex_unlock(&mutx);
      609:  792:		return TRUE;
        -:  793:	}
        -:  794:
      257:  795:	front = (front + 1) % queue_size;
      257:  796:	event = event_arry[front];
        -:  797:	
      257:  798:	pthread_cond_signal(&cond);
      257:  799:  	pthread_mutex_unlock(&mutx);
        -:  800:	
      257:  801:	if(event == Model.max_user*4) 
branch  0 taken 1
branch  1 taken 256
        -:  802:	{
        1:  803:		return FALSE;
        -:  804:	}
        -:  805:
        -:  806:	int movement;
      262:  807:	if((movement = check_validation(event)) == 0) fprintf(stderr,"invalid movement!\n");
branch  0 taken 6
branch  1 taken 250
        -:  808:	else{	
      250:  809:		move(event, movement);
      250:  810:		display_screen();
      250:  811:		if( current_num_item <= 0) {
branch  0 taken 72
branch  1 taken 178
       72:  812:			gameover();
       72:  813:		}
        -:  814:	} 
        -:  815:
      256:  816:    return TRUE;
      866:  817:}
        -:  818:
function cannot_enter called 0 returned 0% blocks executed 0%
    #####:  819:void cannot_enter(){
        -:  820:	// sprintf(msg_info, "Cannot enter the game.\n");
    #####:  821:	fprintf(stderr,"Cannot enter the game.\n");
    #####:  822:}
